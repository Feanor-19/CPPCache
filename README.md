# Сравнение частоты попадания и скорости работы "идеального" алгоритма кэширования и алгоритма LFU

## Установка

### Виртуальное окружение

Все последующие шаги, включая установку conan, можно делать в [виртуальном окружении](https://docs.python.org/3/library/venv.html):

```
python3 -m venv .venv
source .venv/bin/activate
pip3 install conan
```

### Необходимые сторонние инструменты

- cmake >=3.11
- conan >= 2.7.1

Если `conan` используется первый раз, требуется также исполнить: 
```
conan profile detect
```

### Клонирование репозитория

```
git clone https://github.com/Feanor-19/CPPCache
cd CPPCache
```

### Подготовка зависимостей

```
conan install . --output-folder=build --build=missing
```

### Сборка с cmake

```
cd build
cmake .. -DCMAKE_TOOLCHAIN_FILE=conan_toolchain.cmake -DCMAKE_BUILD_TYPE=Release
cmake --build .
```

## Краткое описание алгоритмов

### "Идеальный"

- Кэш знает в момент создания все будущие запросы. 
- Когда нужно выбрать, какой элемент нужно вытолкнуть, выталкивается тот, который будет запрошен позже всех остальных. Но если данный кандидат на выталкивание встретится раньше, чем тот элемент, для которого подыскивается место в кэше, никаких замен не происходит.
- Если элемент, для которого в данный момент ищется место в кэше, больше не будет встречаться, он не помещается в кэш. 

### Least Frequently Used (LFU)

Выталкивается тот элемент, который наименее часто запрашивался (среди тех, которые сейчас есть в кэше).

## Описание теста

В силу того, что результаты отличаются в несколько раз, проведение нескольких тестов не позволяет получить дополнительной информации, и поэтому проводится единственный тест. Данные для теста сгенерированы `scripts/gen_bench_test.py` со следующими параметрами:

|Параметр|Значение|Описание|
|-|-|-|
Cache Size    |1000     | Размер кэша           |
Queries Count |100000   | Количество запросов   |
Queries Range |10000    | Определяет диапазон id запрашиваемых элементов |

Использованный файл теста: `benchmark_data/bench_1000_100000_10000.dat`

__Примечание: В случае промаха кэш вызывает "медленную" функцию получения элемента. В данном тесте эта функция не была никак искусственно замедленна и состояла из единственной строчки `return id;`.__

## Проведение тестов

Для проведения тестов используется средство google benchmark. Для запуска теста нужно выполнить соответствующую программу:

Идеальный кэш (IdealCache):
```
./out/build/Release/IdealCache/IC_benchmark
```

Least Frequently Used Cache (LFUCache):
```
./out/build/Release/LFUCache/LFUC_benchmark
```

## Результаты тестов

Результаты приведены сильно округлёнными в силу значительного различия между собой (в несколько раз), и потому отражают только порядок величин.

|Название алгоритма |Количество попаданий (hits)|Частота попаданий  |Время выполнения, мс   |
|-|-|-|-|
Ideal Cache         |19 308                     |~40%               |~4500                  |
LFU Cache           |9 906                      |~10%               |~150                   |

## Выводы

Идеальный кэш имеет в 4 раза больше попаданий, но невероятно сильно проигрывает по скорости работы. Причин могут быть две:

- Алгоритм вычисления элемента, который встретится позже прочих в будущих запросах, реализован ужасно неэффективно.

- То, что "медленная" функция получения элемента в случае промаха кэша на самом деле работает очень быстро, играет роль и искажает результаты сравнения. 