# Сравнение частоты попадания и скорости работы "идеального" алгоритма кэширования и алгоритма LFU

## Краткое описание алгоритмов


### "Идеальный"

Кэш знает в момент создания все будущие запросы. Когда нужно выбрать, какой элемент нужно вытолкнуть, выталкивается тот, который будет запрошен позже всех остальных.

### Least Frequently Used (LFU)

Выталкивается тот элемент, который наименее часто запрашивался (среди тех, которые сейчас есть в кэше).

## Описание теста

В силу того, что результаты отличаются в несколько раз, проведение нескольких тестов не позволяет получить дополнительной информации, и поэтому проводится единственный тест. Данные для теста сгенерированы `scripts/gen_bench_test.py` со следующими параметрами:

|Параметр|Значение|Описание|
|-|-|-|
Cache Size    |1000     | Размер кэша           |
Queries Count |100000   | Количество запросов   |
Queries Range |10000    | Определяет диапазон id запрашиваемых элементов |

Использованный файл теста: `benchmark_data/bench_1000_100000_10000.dat`

__Примечание: В случае промаха кэш вызывает "медленную" функцию получения элемента. В данном тесте эта функция не была никак искусственно замедленна и состояла из единственной строчки `return id;`.__

## Проведение тестов

Для проведения тестов используется средство google benchmark. Для запуска теста нужно выполнить соответствующую программу:


Идеальный кэш (IdealCache):
```
./out/build/Release/IdealCache/IC_benchmark
```

Least Frequently Used Cache (LFUCache):
```
./out/build/Release/LFUCache/LFUC_benchmark
```

## Результаты тестов

Результаты приведены сильно округлёнными в силу значительного различия между собой (в несколько раз), и потому отражают только порядок величин.

|Название алгоритма |Количество попаданий (hits)|Частота попаданий  |Время выполнения, мс   |
|-|-|-|-|
Ideal Cache         |~40 000                    |~40%               |~10 000                |
LFU Cache           |~10 000                    |~10%               |~500                   |

## Выводы

Идеальный кэш имеет в 4 раза больше попаданий, но невероятно сильно проигрывает по скорости работы. Причин могут быть две:

- Алгоритм вычисления элемента, который встретится позже прочих в будущих запросах, реализован ужасно неэффективно.

- То, что "медленная" функция получения элемента в случае промаха кэша на самом деле работает очень быстро, играет роль и искажает результаты сравнения. 